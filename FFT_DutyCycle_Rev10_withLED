#!/usr/bin/env python3
# Geophone FFT + LoRa + RGB LED Status Script

import time
import math
import numpy as np
import matplotlib.pyplot as plt
import Adafruit_ADS1x15
import csv
import board
import busio
import digitalio
import adafruit_rfm9x
import RPi.GPIO as GPIO

# -------------------------
# IDs for this node & Brain
# -------------------------
DEVICE_ID = "1.0"   # This geophone node
BRAIN_ID  = "0.1"   # The Brain node

# ========================================================
# RGB LED SETUP (BCM pins)
# ========================================================
# Red   -> BCM 16 (physical 36)
# Green -> BCM 20 (physical 38)
# Blue  -> BCM 21 (physical 40)
# GND   -> Pin 39 (common cathode)

GPIO.setmode(GPIO.BCM)

RED_PIN = 16
GREEN_PIN = 20
BLUE_PIN = 21

GPIO.setup(RED_PIN, GPIO.OUT)
GPIO.setup(GREEN_PIN, GPIO.OUT)
GPIO.setup(BLUE_PIN, GPIO.OUT)

def led_off():
    GPIO.output(RED_PIN, GPIO.LOW)
    GPIO.output(GREEN_PIN, GPIO.LOW)
    GPIO.output(BLUE_PIN, GPIO.LOW)

def solid_green():
    GPIO.output(RED_PIN, GPIO.LOW)
    GPIO.output(GREEN_PIN, GPIO.HIGH)
    GPIO.output(BLUE_PIN, GPIO.LOW)

def solid_yellow():
    GPIO.output(RED_PIN, GPIO.HIGH)
    GPIO.output(GREEN_PIN, GPIO.HIGH)
    GPIO.output(BLUE_PIN, GPIO.LOW)

def flash_green(times=3, on_time=1.0, off_time=0.5):
    for _ in range(times):
        solid_green()
        time.sleep(on_time)
        led_off()
        time.sleep(off_time)

def flash_yellow(times=3, on_time=1.0, off_time=0.5):
    for _ in range(times):
        solid_yellow()
        time.sleep(on_time)
        led_off()
        time.sleep(off_time)

# ========================================================
# ADC / LoRa INITIALIZATION
# ========================================================

adc = Adafruit_ADS1x15.ADS1115(address=0x48, busnum=1)

CS = digitalio.DigitalInOut(board.CE1)
RESET = digitalio.DigitalInOut(board.D25)
spi = busio.SPI(board.SCK, MOSI=board.MOSI, MISO=board.MISO)

rfm9x = adafruit_rfm9x.RFM9x(spi, CS, RESET, 433.0)

# Gain settings used for ADC
GAIN_ONE = 1
GAIN = GAIN_ONE

# Voltage range lookup for gains
GAIN_VOLTAGE_RANGE = {
    2/3: 6.144,
    1:   4.096,
    2:   2.048,
    4:   1.024,
    8:   0.512,
    16:  0.256
}

fsr = GAIN_VOLTAGE_RANGE[GAIN]
lsb_size = (fsr * 2) / 65536

# Sampling parameters
ADC_DATA_RATE = 250
collect_duration = 10.0
wait_duration = 5.0
thumper_avoidance_duration = 300.0
time_per_sample = 1.0 / ADC_DATA_RATE
threshold_mode = 1.0

# CSV logging
SPIKES_LOG_FILE = "fft_spikes.csv"
def init_spike_log():
    with open(SPIKES_LOG_FILE, "w", newline="") as f:
        csv.writer(f).writerow(["Frequency (Hz)", "Spike Type", "Value"])

def log_spike(freq, spike_type, value):
    with open(SPIKES_LOG_FILE, "a", newline="") as f:
        csv.writer(f).writerow([freq, spike_type, value])

# ========================================================
# LoRa Receive Check
# ========================================================
def check_for_lora_rx():
    try:
        packet = rfm9x.receive(timeout=0.1)
    except Exception as e:
        print("[GEO] RX ERROR:", e)
        return

    if packet is None:
        return

    try:
        text = packet.decode("utf-8", errors="ignore").strip()
    except:
        text = repr(packet)

    print(f"[GEO] LoRa RX: '{text}'")

    if text.startswith(BRAIN_ID):
        print("[GEO] >>> RECEIVED MESSAGE FROM 0.1 (BRAIN) <<<")
        flash_yellow()  # ðŸŸ¡ flash on receive

# ========================================================
# MAIN LOOP
# ========================================================

init_spike_log()

print("[GEO] STARTED")
print(f"[GEO] Node ID: {DEVICE_ID}, listening for {BRAIN_ID}")

try:
    while True:
        check_for_lora_rx()

        print(f"\n[GEO] Collecting {collect_duration}s of data...")
        start_time = time.perf_counter()
        data = []
        timestamps = []

        # -----------------------------
        # ADC reading loop
        # -----------------------------
        while True:
            now = time.perf_counter()
            if now - start_time >= collect_duration:
                break

            val = adc.read_adc_difference(0, gain=GAIN, data_rate=ADC_DATA_RATE)
            data.append(val)
            timestamps.append(now)
            time.sleep(time_per_sample)

        print("[GEO] Data collection complete")

        # Actual sample rate check
        diffs = np.diff(timestamps)
        actual_rate = 1.0 / np.mean(diffs)
        print(f"[GEO] Actual Fs: {actual_rate:.2f} Hz")

        # -----------------------------
        # FFT PROCESSING
        # -----------------------------
        voltages = np.array(data) * lsb_size
        v_detr = voltages - np.mean(voltages)
        window = np.hanning(len(v_detr))
        wv = v_detr * window

        fft_vals = np.fft.fft(wv)
        magnitude = np.abs(fft_vals)
        power = (magnitude ** 2) / 2

        freq = np.fft.fftfreq(len(magnitude), d=1.0 / actual_rate)
        half = len(freq) // 2

        freq = freq[:half]
        magnitude = magnitude[:half]
        power = power[:half]

        # -----------------------------
        # DYNAMIC THRESHOLDS
        # -----------------------------
        if threshold_mode == 1.0:
            mag_th = np.median(magnitude) + 2.5*np.std(magnitude)
            pow_th = np.median(power) + 5*np.std(power)
        else:
            mag_th = 10
            pow_th = 100

        detected_mag = freq[magnitude > mag_th]
        detected_mag_vals = magnitude[magnitude > mag_th]

        detected_pow = freq[power > pow_th]
        detected_pow_vals = power[power > pow_th]

        spike_confirm = False

        # Magnitude spikes
        if len(detected_mag) > 0:
            spike_confirm = True
            print("[GEO] Magnitude spikes:")
            for f, mv in zip(detected_mag, detected_mag_vals):
                print(f"  {f:.2f} Hz, Mag={mv:.2f}")
                log_spike(f, "Magnitude", mv)

        # Power spikes
        if len(detected_pow) > 0:
            spike_confirm = True
            print("[GEO] Power spikes:")
            for f, pv in zip(detected_pow, detected_pow_vals):
                print(f"  {f:.2f} Hz, Pow={pv:.3f}")
                log_spike(f, "Power", pv)

        # ========================================================
        # SEND TO BRAIN IF SPIKE OCCURS
        # ========================================================
        msg = DEVICE_ID.encode()

        print(f"[GEO] SENDING MESSAGE FROM {DEVICE_ID}...")
        flash_green()  # ðŸ’š flash on send

        try:
            rfm9x.send(msg)
            print("[GEO] SEND OK")
        except Exception as e:
            print("[GEO] SEND FAILED:", e)

        # Immediately listen for reply
        check_for_lora_rx()

        # ========================================================
        # WAIT LOGIC
        # ========================================================
        if spike_confirm:
            print(f"[GEO] Spike = TRUE. Waiting {thumper_avoidance_duration} seconds...")
            time.sleep(thumper_avoidance_duration)
        else:
            print(f"[GEO] No spike. Waiting {wait_duration} seconds...")
            time.sleep(wait_duration)

except KeyboardInterrupt:
    print("\n[GEO] Manual stop, cleaning up...")

finally:
    led_off()
    GPIO.cleanup()
    print("[GEO] GPIO cleaned up. Exiting.")
